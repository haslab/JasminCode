/*
dependencies:
- complex.jinc
- parameter defs (cloudplus128_params.jinc or cloudplus192_params.jinc or cloudplus256_params.jinc)
*/

namespace BW2 {
  inline fn bdd_bw
  ( reg mut ptr complex[1] y
  , reg const ptr complex[1] t
  ) -> reg ptr complex[1]
  {
   reg complex c;
   c = t[0];
   c = complex_myround(c);
   y[0] = c;
   return y;
  }
}

namespace BW4 {
  param int BW = 4;
  inline fn fRec(reg mut ptr complex[BW/4] y, reg const ptr complex[BW/4] t) -> reg ptr complex[BW/4]
  { y = BW2::bdd_bw(y, t); return y; }
  require "bdd_BW.jinc"
}

namespace BW8 {
  param int BW = 8;
  inline fn fRec(reg mut ptr complex[BW/4] y, reg const ptr complex[BW/4] t) -> reg ptr complex[BW/4]
  { y = BW4::bdd_bw(y, t); return y; }
  require "bdd_BW.jinc"
}

namespace BW16 {
  param int BW = 16;
  inline fn fRec(reg mut ptr complex[BW/4] y, reg const ptr complex[BW/4] t) -> reg ptr complex[BW/4]
  { y = BW8::bdd_bw(y, t); return y; }
  require "bdd_BW.jinc"
}

namespace BW32 {
  param int BW = 32;
  inline fn fRec(reg mut ptr complex[BW/4] y, reg const ptr complex[BW/4] t) -> reg ptr complex[BW/4]
  { y = BW16::bdd_bw(y, t); return y; }
  require "bdd_BW.jinc"
}

fn _compute_v
( reg mut ptr complex[16] v
, reg const ptr u8[Params::mu / 8] m
) -> reg ptr complex[16]
{
  inline int i;
  stack u8[6] A, C;
  stack u8[20] B;
  reg double re, im;
  reg u64 mm;
  reg u32 nn;
  reg u8 t;

  if (Params::tau==3) { // mu=64, mu8=8
    mm = m.[:u64 0];
    for i = 0 to 6 {
      t = (8u) mm;
      mm >>= 3;
      t &= 0x07;
      A[i] = t;
    }
    for i = 0 to 20 {
      t = (8u) mm;
      mm >>= 2;
      t &= 0x03;
      B[i] = t;
    }
    for i = 0 to 5 {
      t = (8u) mm;
      mm >>= 1;
      t &= 0x01;
      C[i] = t;
    }
    C[5] = (8u) mm;
  } else { //Params::tau==4, mu=96, mu8=12
    mm = m.[:u64 0];
    nn = m.[:u32 8];
    for i = 0 to 6 {
      t = (8u) mm;
      mm >>= 4;
      t &= 0x0F;
      A[i] = t;
    }// 0,1,2
    for i = 0 to 13 {
      t = (8u) mm;
      mm >>= 3;
      t &= 0x07;
      B[i] = t;
    }
    t = (8u) nn;
    nn >>= 2;
    t <<= 1;
    t &= 0x06;
    t |= (8u) mm;
    B[13] = t;
    for i = 14 to 20 {
      t = (8u) nn;
      nn >>= 3;
      t &= 0x07;
      B[i] = t;
    }
    for i = 0 to 5 {
      t = (8u) nn;
      nn >>= 2;
      t &= 0x03;
      C[i] = t;
    }
    C[5] = (8u) nn;
  }
  re = double_from_u64((64u) A[0]);
  im = double_from_u64((64u) A[1]);
  v[0] = complex_pack(re, im);
  re = double_from_u64((64u) A[2]);
  im = double_from_u64((64u) B[0]);
  v[1] = complex_pack(re, im);
  re = double_from_u64((64u) A[3]);
  im = double_from_u64((64u) B[1]);
  v[2] = complex_pack(re, im);
  re = double_from_u64((64u) B[2]);
  im = double_from_u64((64u) B[3]);
  v[3] = complex_pack(re, im);
  re = double_from_u64((64u) A[4]);
  im = double_from_u64((64u) B[4]);
  v[4] = complex_pack(re, im);
  re = double_from_u64((64u) B[5]);
  im = double_from_u64((64u) B[6]);
  v[5] = complex_pack(re, im);
  re = double_from_u64((64u) B[7]);
  im = double_from_u64((64u) B[8]);
  v[6] = complex_pack(re, im);
  re = double_from_u64((64u) B[9]);
  im = double_from_u64((64u) C[0]);
  v[7] = complex_pack(re, im);
  re = double_from_u64((64u) A[5]);
  im = double_from_u64((64u) B[10]);
  v[8] = complex_pack(re, im);
  re = double_from_u64((64u) B[11]);
  im = double_from_u64((64u) B[12]);
  v[9] = complex_pack(re, im);
  re = double_from_u64((64u) B[13]);
  im = double_from_u64((64u) B[14]);
  v[10] = complex_pack(re, im);
  re = double_from_u64((64u) B[15]);
  im = double_from_u64((64u) C[1]);
  v[11] = complex_pack(re, im);
  re = double_from_u64((64u) B[16]);
  im = double_from_u64((64u) B[17]);
  v[12] = complex_pack(re, im);
  re = double_from_u64((64u) B[18]);
  im = double_from_u64((64u) C[2]);
  v[13] = complex_pack(re, im);
  re = double_from_u64((64u) B[19]);
  im = double_from_u64((64u) C[3]);
  v[14] = complex_pack(re, im);
  re = double_from_u64((64u) C[4]);
  im = double_from_u64((64u) C[5]);
  v[15] = complex_pack(re, im);

  return v;
}

fn _compute_w
( reg mut ptr u16[32] w
, reg const ptr complex[16] v
) -> reg ptr u16[32]
{
  inline int i;
  stack complex[16] tmp;
  reg complex base, c1, c2;
  reg double re, im;
  reg u64 re64, im64;
  reg u16 t;

  base = complex_one_one;

  for i = 0 to 8 {
    c1 = v[2*i];
    c2 = v[2*i+1];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[2*i] = c1;
    tmp[2*i+1] = c2;
  }
  for i = 0 to 4 {
    c1 = tmp[4*i];
    c2 = tmp[4*i+2];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[4*i+2] = c2;
    c1 = tmp[4*i+1];
    c2 = tmp[4*i+3];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[4*i+3] = c2;
  }
  for i = 0 to 2 {
    c1 = tmp[8*i];
    c2 = tmp[8*i+4];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[8*i+4] = c2;
    c1 = tmp[8*i+1];
    c2 = tmp[8*i+5];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[8*i+5] = c2;
    c1 = tmp[8*i+2];
    c2 = tmp[8*i+6];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[8*i+6] = c2;
    c1 = tmp[8*i+3];
    c2 = tmp[8*i+7];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[8*i+7] = c2;
  }
  for i = 0 to 8 {
    c1 = tmp[i];
    c2 = tmp[i+8];
    c2 = complex_mul(c2,base);
    c2 = complex_add(c2,c1);
    tmp[i+8] = c2;
  }

  if (Params::tau == 3) {
    //x = 512; // 1 << (scloudplus_logq - 3);
    for i = 0 to 16 {
      c1 = tmp[i];
      re, im = complex_unpack(c1);
      re64 = double_trunc_u64(re);
      im64 = double_trunc_u64(im);
      re64 &= 0x07;
      t = (16u) re64;
      t <<= 9; //t*x
      t &= 0xFFF;
      w[2*i] = t;
      im64 &= 0x07;
      t = (16u) im64;
      t <<= 9; //t*x
      t &= 0xFFF;
      w[2*i+1] = t;
    }
  } else { //Params::tau==4
    //x = 256; // 1 << (scloudplus_logq - 3);
    for i = 0 to 16 {
      c1 = tmp[i];
      re, im = complex_unpack(c1);
      re64 = double_trunc_u64(re);
      im64 = double_trunc_u64(im);
      re64 &= 0x0F;
      t = (16u) re64;
      t <<= 8; //t*x
      t &= 0xFFF;
      w[2*i] = t;
      im64 &= 0x0F;
      t = (16u) im64;
      t <<= 8; //t*x
      t &= 0xFFF;
      w[2*i+1] = t;
    }
  }
  return w;
}

inline fn __trunc_mask
( reg complex c
, inline int mask
) -> reg complex
{
  reg double re, im;
  reg u64 re_u64, im_u64;
  re, im = complex_unpack(c);
  re_u64 = #CVTTSD2SI(re);
  re_u64 &= mask;
  re = #CVTSI2SD(re_u64);
  im_u64 = #CVTTSD2SI(im);
  im_u64 &= mask;
  im = #CVTSI2SD(im_u64);
  c = complex_pack(re, im);
  return c;
}

inline fn __trunc_mod
( reg complex c
, inline int mask1 mask2
) -> reg complex
{
// mod = (int)inout[1].imag & 0x3;
// sub = mod - (int)inout[1].imag;
// inout[1] = (Complex){(double)(((int)inout[1].real + (int)sub) & 0x7), (double)mod};
  reg double re, im;
  reg u64 re_u64, im_u64, sub;
  re, im = complex_unpack(c);
  re_u64 = #CVTTSD2SI(re);
  im_u64 = #CVTTSD2SI(im);
  sub = im_u64;
  sub &= mask1; 
  im = #CVTSI2SD(sub); // mod
  sub -= im_u64;
  re_u64 += sub;
  re_u64 &= mask2;
  re = #CVTSI2SD(re_u64);
  c = complex_pack(re, im);
  return c;
}

fn _reduce_w
( reg mut ptr complex[16] inout
) -> reg ptr complex[16]
{
  reg complex c;
  if (Params::tau==3) {
    c = inout[0]; c = __trunc_mask(c, 0x07); inout[0] = c;
    c = inout[3]; c = __trunc_mask(c, 0x03); inout[3] = c;
    c = inout[5]; c = __trunc_mask(c, 0x03); inout[5] = c;
    c = inout[6]; c = __trunc_mask(c, 0x03); inout[6] = c;
    c = inout[9]; c = __trunc_mask(c, 0x03); inout[9] = c;
    c = inout[10]; c = __trunc_mask(c, 0x03); inout[10] = c;
    c = inout[12]; c = __trunc_mask(c, 0x03); inout[12] = c;
    c = inout[15]; c = __trunc_mask(c, 0x01); inout[15] = c;
    c = inout[1]; c = __trunc_mod(c, 0x03, 0x07); inout[1] = c;
    c = inout[2]; c = __trunc_mod(c, 0x03, 0x07); inout[2] = c;
    c = inout[4]; c = __trunc_mod(c, 0x03, 0x07); inout[4] = c;
    c = inout[8]; c = __trunc_mod(c, 0x03, 0x07); inout[8] = c;
    c = inout[7]; c = __trunc_mod(c, 0x01, 0x03); inout[7] = c;
    c = inout[11]; c = __trunc_mod(c, 0x01, 0x03); inout[11] = c;
    c = inout[13]; c = __trunc_mod(c, 0x01, 0x03); inout[13] = c;
    c = inout[14]; c = __trunc_mod(c, 0x01, 0x03); inout[14] = c;
  } else { // Params::tau==4
    c = inout[0]; c = __trunc_mask(c, 0x0F); inout[0] = c;
    c = inout[3]; c = __trunc_mask(c, 0x07); inout[3] = c;
    c = inout[5]; c = __trunc_mask(c, 0x07); inout[5] = c;
    c = inout[6]; c = __trunc_mask(c, 0x07); inout[6] = c;
    c = inout[9]; c = __trunc_mask(c, 0x07); inout[9] = c;
    c = inout[10]; c = __trunc_mask(c, 0x07); inout[10] = c;
    c = inout[12]; c = __trunc_mask(c, 0x07); inout[12] = c;
    c = inout[15]; c = __trunc_mask(c, 0x03); inout[15] = c;
    c = inout[1]; c = __trunc_mod(c, 0x07, 0x0F); inout[1] = c;
    c = inout[2]; c = __trunc_mod(c, 0x07, 0x0F); inout[2] = c;
    c = inout[4]; c = __trunc_mod(c, 0x07, 0x0F); inout[4] = c;
    c = inout[8]; c = __trunc_mod(c, 0x07, 0x0F); inout[8] = c;
    c = inout[7]; c = __trunc_mod(c, 0x03, 0x07); inout[7] = c;
    c = inout[11]; c = __trunc_mod(c, 0x03, 0x07); inout[11] = c;
    c = inout[13]; c = __trunc_mod(c, 0x03, 0x07); inout[13] = c;
    c = inout[14]; c = __trunc_mod(c, 0x03, 0x07); inout[14] = c;    
  }
  return inout;
}

inline fn vecv_A
( inline int n
) -> inline int
{
  inline int r = 0; // A[0]
  if ( n == 1 ) { r = 1; }
  else if ( n == 2 ) { r = 2; }
  else if ( n == 3 ) { r = 4; }
  else if ( n == 4 ) { r = 8; }
  else if ( n == 5 ) { r = 16; }
  return r;
}

inline fn vecv_B
( inline int n
) -> inline int
{
  inline int r = 3; // B[0]
  if ( n == 1 ) { r = 5; }
  else if ( n == 2 ) { r = 6; }
  else if ( n == 3 ) { r = 7; }
  else if ( n == 4 ) { r = 9; }
  else if ( n == 5 ) { r = 10; }
  else if ( n == 6 ) { r = 11; }
  else if ( n == 7 ) { r = 12; }
  else if ( n == 8 ) { r = 13; }
  else if ( n == 9 ) { r = 14; }
  else if ( n == 10 ) { r = 17; }
  else if ( n == 11 ) { r = 18; }
  else if ( n == 12 ) { r = 19; }
  else if ( n == 13 ) { r = 20; }
  else if ( n == 14 ) { r = 21; }
  else if ( n == 15 ) { r = 22; }
  else if ( n == 16 ) { r = 24; }
  else if ( n == 17 ) { r = 25; }
  else if ( n == 18 ) { r = 26; }
  else if ( n == 19 ) { r = 28; }
  return r;
}

inline fn vecv_C
( inline int n
) -> inline int
{
  inline int r = 15; // C[0]
  if ( n == 1 ) { r = 23; }
  else if ( n == 2 ) { r = 27; }
  else if ( n == 3 ) { r = 29; }
  else if ( n == 4 ) { r = 30; }
  else if ( n == 5 ) { r = 31; }
  return r;
}

fn _recover_m
( reg mut ptr u8[Params::mu/8] m
, reg const ptr complex[16] v
) -> reg ptr u8[Params::mu/8]
{
  inline int i, j;
  stack u16[32] vecv;
  reg complex c;
  reg double re, im;
  reg u64 t64;
  reg u16 t16;
  reg u8 t8;

  for i = 0 to 16 {
    c = v[i];
    c = complex_myround(c);
    re, im = complex_unpack(c);
    t64 = double_trunc_u64(re);
    vecv[2*i] = (16u) t64;
    t64 = double_trunc_u64(im);
    vecv[2*i+1] = (16u) t64;
  }

  if ( Params::tau == 3 ) {
    // m[7]
    j = vecv_C(5);
    t8 = vecv[:u8 (2*j)];
    for i = 4 downto -1 {
      j = vecv_C(i);
      t16 = vecv[j];
      t8 <<= 1;
      t8 |= (8u) t16;
    }
    t8 <<= 2;
    j = vecv_B(19);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[7] = t8;
    // m[6]
    j = vecv_B(18);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 2;
    j = vecv_B(17);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(16);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(15);
    t16 = vecv[j];
    t8 |= t16;
    m[6] = t8;
    // m[5]
    j = vecv_B(14);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 2;
    j = vecv_B(13);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(12);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(11);
    t16 = vecv[j];
    t8 |= t16;
    m[5] = t8;
    // m[4]
    j = vecv_B(10);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 2;
    j = vecv_B(9);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(8);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(7);
    t16 = vecv[j];
    t8 |= t16;
    m[4] = t8;
    // m[3]
    j = vecv_B(6);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 2;
    j = vecv_B(5);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(4);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(3);
    t16 = vecv[j];
    t8 |= t16;
    m[3] = t8;
    // m[2]
    j = vecv_B(2);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 2;
    j = vecv_B(1);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_B(0);
    t16 = vecv[j];
    t8 |= t16;
    t8 <<= 2;
    j = vecv_A(5);
    t16 = vecv[j];
    t16 >>= 1;
    t8 |= (8u) t16;
    m[2] = t8;
    // m[1]
    j = vecv_A(5);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 7;
    j = vecv_A(4);
    t16 = vecv[j];
    t16 <<= 4;
    t8 |= (8u) t16;
    j = vecv_A(3);
    t16 = vecv[j];
    t16 <<= 1;
    t8 |= (8u) t16;
    j = vecv_A(2);
    t16 = vecv[j];
    t16 >>= 2;
    t8 |= (8u) t16;
    m[1] = t8;
    // m[0]
    j = vecv_A(2);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 6;
    j = vecv_A(1);
    t16 = vecv[j];
    t16 <<= 3;
    t8 |= (8u) t16;
    j = vecv_A(0);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[0] = t8;
  } else { // Params::tau == 4
    // m[11]
    j = vecv_C(5);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 6;
    j = vecv_C(4);
    t16 = vecv[j];
    t16 <<= 4;
    t8 |= (8u) t16;
    j = vecv_C(3);
    t16 = vecv[j];
    t16 <<= 2;
    t8 |= (8u) t16;
    j = vecv_C(2);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[11] = t8;
    // m[10]
    j = vecv_C(1);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 6;
    j = vecv_C(0);
    t16 = vecv[j];
    t16 <<= 4;
    t8 |= (8u) t16;
    j = vecv_B(19);
    t16 = vecv[j];
    t16 <<= 1;
    t8 |= (8u) t16;
    j = vecv_B(18);
    t16 = vecv[j];
    t16 >>= 2;
    t8 |= (8u) t16;
    m[10] = t8;
    // m[9]
    j = vecv_B(18);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 6;
    j = vecv_B(17);
    t16 = vecv[j];
    t16 <<= 3;
    t8 |= (8u) t16;
    j = vecv_B(16);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[9] = t8;
    // m[8]
    j = vecv_B(15);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 5;
    j = vecv_B(14);
    t16 = vecv[j];
    t16 <<= 2;
    t8 |= (8u) t16;
    j = vecv_B(13);
    t16 = vecv[j];
    t16 >>= 1;
    t8 |= (8u) t16;
    m[8] = t8;
    // m[7]
    j = vecv_B(13);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 7;
    j = vecv_B(12);
    t16 = vecv[j];
    t16 <<= 4;
    t8 |= (8u) t16;
    j = vecv_B(11);
    t16 = vecv[j];
    t16 <<= 1;
    t8 |= (8u) t16;
    j = vecv_B(10);
    t16 = vecv[j];
    t16 >>= 2;
    t8 |= (8u) t16;
    m[7] = t8;
    // m[6]
    j = vecv_B(10);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 6;
    j = vecv_B(9);
    t16 = vecv[j];
    t16 <<= 3;
    t8 |= (8u) t16;
    j = vecv_B(8);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[6] = t8;
    // m[5]
    j = vecv_B(7);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 5;
    j = vecv_B(6);
    t16 = vecv[j];
    t16 <<= 2;
    t8 |= (8u) t16;
    j = vecv_B(5);
    t16 = vecv[j];
    t16 >>= 1;
    t8 |= (8u) t16;
    m[5] = t8;
    // m[4]
    j = vecv_B(5);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 7;
    j = vecv_B(4);
    t16 = vecv[j];
    t16 <<= 4;
    t8 |= (8u) t16;
    j = vecv_B(3);
    t16 = vecv[j];
    t16 <<= 1;
    t8 |= (8u) t16;
    j = vecv_B(2);
    t16 = vecv[j];
    t16 >>= 2;
    t8 |= (8u) t16;
    m[4] = t8;
    // m[3]
    j = vecv_B(2);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 6;
    j = vecv_B(1);
    t16 = vecv[j];
    t16 <<= 3;
    t8 |= (8u) t16;
    j = vecv_B(0);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[3] = t8;
    // m[2]
    j = vecv_A(5);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 4;
    j = vecv_A(4);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[2] = t8;
    // m[1]
    j = vecv_A(3);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 4;
    j = vecv_A(2);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[1] = t8;
    // m[0]
    j = vecv_A(1);
    t8 = vecv[:u8 (2*j)];
    t8 <<= 4;
    j = vecv_A(0);
    t16 = vecv[j];
    t8 |= (8u) t16;
    m[0] = t8;
  }
  
  return m;
}

fn _recover_v
( reg mut ptr complex[16] v
, reg const ptr complex[16] w
) -> reg ptr complex[16]
{
  inline int i, j;
  reg complex c1, c2, hh;
  hh = complex_half_minushalf;
  for i = 0 to 8 {
    c1 = w[i];
    c2 = w[i+8];
    c2 = complex_sub(c2, c1);
    c2 = complex_mul(c2, hh);
    v[i] = c1;
    v[i+8] = c2;
  }
  for i = 0 to 2 {
    for j = 0 to 4 {
      c1 = v[8*i + 4 + j];
      c2 = v[8*i + j];
      c1 = complex_sub(c1, c2);
      c1 = complex_mul(c1, hh);
      v[8*i + 4 + j] = c1;
    }
  }
  for i = 0 to 4 {
    for j = 0 to 2 {
      c1 = v[4*i + 2 + j];
      c2 = v[4*i + j];
      c1 = complex_sub(c1, c2);
      c1 = complex_mul(c1, hh);
      v[4*i + 2 + j] = c1;
    }
  }
  for i = 0 to 8 {
    c1 = v[2*i + 1];
    c2 = v[2*i];
    c1 = complex_sub(c1, c2);
    c1 = complex_mul(c1, hh);
    v[2*i + 1] = c1;
  }
  v = _reduce_w(v);
  return v;
}

fn _msgencode
( reg mut ptr u16[Params::mbar*Params::nbar] matM
, reg const ptr u8[Params::subm*Params::mu/8] msg
) -> reg ptr u16[Params::mbar*Params::nbar]
{
  stack complex[16] v;
  reg ptr u8[Params::mu/8] mm;
  reg ptr u16[32] slice;
  inline int i;
  for i = 0 to Params::subm {
    mm = msg[i*Params::mu/8 : Params::mu/8];
    v = _compute_v(v, mm);
    slice = matM[i*32 : 32];
    slice = _compute_w(slice, v);
    matM[i*32 : 32] = slice;
  }
  if (Params::l==256) { // we need to fill the last 4 entries with 0s!!!
    matM[:u64 32] = 0;
  }
  return matM;
}

fn _msgdecode
( reg mut ptr u8[Params::subm*Params::mu/8] msg
, reg const ptr u16[Params::mbar*Params::nbar] matM
) -> reg ptr u8[Params::subm*Params::mu/8]
{
  inline int i, j;
  reg ptr u8[Params::mu/8] mm;
  stack complex[16] w, v;
  reg double re, im, cnst, two_tau;
  reg complex c;

  cnst = double__000244140625;
  if (Params::tau==3) {
    two_tau = double_8;
  } else {
    two_tau = double_16;
  }
  for i = 0 to Params::mu/64 { msg.[:u64 i] = 0; }
  for i = 0 to Params::subm {
    for j = 0 to 16 {
      re = double_from_u64((64u) matM[32*i+2*j]);
      re = double_mul(re, two_tau);
      re = double_mul(re, cnst);
      im = double_from_u64((64u) matM[32*i+2*j+1]);
      im = double_mul(im, two_tau);
      im = double_mul(im, cnst);
      c = complex_pack(re, im);
      v[j] = c;
    }
    w = BW32::bdd_bw(w, v);
    v = _recover_v(v, w);
    mm = msg[i*Params::mu/8 : Params::mu/8];
    mm = _recover_m(mm, v);
    msg[i*Params::mu/8 : Params::mu/8] = mm;
  }
  return msg;
}

inline fn SHL( reg u64 x, inline int sh) -> reg u64
{
  if ( sh != 0) { x <<= sh; }
  return x;
}

inline fn pack4
( reg u64 x
, reg u64 r
, inline int cbits
, inline int nbits
) -> reg u64
{
  reg u64 t;
  inline int i;

  for i = 0 to 4 {
    t = x;
    t &= ((1 << nbits)-1);
    t = SHL(t, i*nbits+cbits);
    r |= t;
    x >>= 16;
  }

  return r;
}

inline fn unpack4
( reg u64 x
, inline int nbits
) -> reg u64
{
  reg u64 t, r;
  inline int i;

  r = 0;
  for i = 0 to 4 {
    t = x;
    t &= ((1 << nbits)-1);
    t = SHL(t, i*16);
    r |= t;
    x >>= nbits;
  }

  return r;
}

inline fn unpack4_sext
( reg u64 x
, inline int nbits
) -> reg u64
{
  reg u64 t, r;
  reg u16 t16;
  inline int i;

  r = 0;
  for i = 0 to 4 {
    t16 = (16u)x;
    t16 &= ((1 << nbits)-1);
    t16 <<= 16-nbits;
    t16 >>s= 16-nbits;
    t = (64u) t16;
    t = SHL(t, i*16);
    r |= t;
    x >>= nbits;
  }

  return r;
}

//     , funD('packpk','j_packpk', [argT.oarr(np.uint8,((P.m*P.nbar*P.logq)//8,)),argT.iarr(np.uint16,(P.m,P.nbar))])
fn packpk
( reg mut ptr u8[Params::m*Params::nbar*Params::logq/8] pk
, reg const ptr u16[Params::m*Params::nbar] B
) -> reg ptr u8[Params::m*Params::nbar*Params::logq/8] /* pk */
{ 
  reg u64 x, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( i < 2*Params::m*Params::nbar ) { // obs: 8 %| Params::m*Params::nbar
    x = B.[:u64 i];
    r = 0;
    r = pack4(x, r, 0, 12);
    pk.[:u32 j] = (32u) r;
    r >>= 32;
    x = B.[:u64 i+8];
    r = pack4(x, r, 16, 12);
    pk.[:u64 j+4] = r;
    j += 12;
    i += 16;
  }

  return pk;
}

//      , funD('unpackpk','j_unpackpk', [argT.oarr(np.uint16,(P.m,P.nbar)),argT.iarr(np.uint8,((P.m*P.nbar*P.logq)//8,))])
fn unpackpk
( reg mut ptr u16[Params::m*Params::nbar] B
, reg const ptr u8[Params::m*Params::nbar*Params::logq/8] pk
) -> reg ptr u16[Params::m*Params::nbar] /* B */
{
  reg u64 x, y, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( j < 2*Params::m*Params::nbar ) { // obs: 8 %| Params::m*Params::nbar
    x = pk.[:u64 i];
    y = x;
    y >>= 48;
    r = unpack4(x, 12);
    B.[:u64 j] = r;
    x = (64u) pk.[:u32 i+8];
    x <<= 16;
    x |= y;
    r = unpack4(x, 12);
    B.[:u64 j+8] = r;
    j += 16;
    i += 12;
  }
 return B;
}


//      , funD('packsk','j_packsk', [argT.oarr(np.uint8,(P.pke_sk,)),argT.iarr(np.uint16,(P.nbar,P.n))])
fn packsk
( reg mut ptr u8[Params::pke_sk] sk
, reg const ptr u16[Params::n*Params::nbar] S
) -> reg ptr u8[Params::pke_sk] /* sk */
{
  reg u64 x, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( i < 2*Params::n*Params::nbar ) { // obs: 8 %| Params::n*Params::nbar
    x = S.[:u64 i];
    r = 0;
    r = pack4(x, r, 0, 2);
    x = S.[:u64 i+8];
    r = pack4(x, r, 8, 2);
    sk.[:u16 j] = (16u) r;
    j += 2;
    i += 16;
  }

  return sk;
}


//      , funD('unpacksk','j_unpacksk', [argT.oarr(np.uint16,(P.nbar,P.n)),argT.iarr(np.uint8,(P.pke_sk,))])
fn unpacksk
( reg mut ptr u16[Params::n*Params::nbar] S
, reg const ptr u8[Params::pke_sk] sk
) -> reg mut ptr u16[Params::n*Params::nbar] /* S */
{
  reg u64 x, y, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( j < 2*Params::n*Params::nbar ) { // obs: 8 %| Params::m*Params::nbar
    x = (64u) sk.[:u16 i];
    y = x;
    r = unpack4_sext(x, 2);
    S.[:u64 j] = r;
    y >>= 8;
    r = unpack4_sext(y, 2);
    S.[:u64 j+8] = r;
    j += 16;
    i += 2;
  }
 return S;
}

/*
128
12, 9, 7
192
12, 12, 10
256
12, 10, 7
*/

inline fn compress_q1
( reg u16 x
, inline int logq1
) -> reg u16 /* x */
{
  reg u32 y;
  y = (32u) x;
  y <<= logq1;
  y += 2048;
  y >>= 12;
  y &= ((1<<logq1)-1);
  x = (16u) y;
  return x;
}

//      , funD('compressc1','j_compressc1', [argT.oarr(np.uint16,(P.mbar,P.n)),argT.iarr(np.uint16,(P.mbar,P.n))])
fn compressc1
( reg mut ptr u16[Params::mbar*Params::n] C1
) -> reg ptr u16[Params::mbar*Params::n] /* C1 */
{
  reg u64 i;
  reg u16 x;
  if ( Params::logq1 != 12 ) {
    i = 0;
    while ( i < Params::mbar*Params::n ) {
      x = C1[i];
      x = compress_q1(x, Params::logq1);
      C1[i] = x;
      i += 1;
    }
  }
  return C1;
}

inline fn decompress_q1
( reg u16 x
, inline int logq1
) -> reg u16 /* x */
{
  reg u32 y;
  y = (32u) x;
  y &= ((1<<logq1)-1);
  y <<= 12;
  y += 256;
  y >>= logq1;
  x = (16u) y;
  return x;
}

//      , funD('decompressc1','j_decompressc1', [argT.oarr(np.uint16,(P.mbar,P.n)),argT.iarr(np.uint16,(P.mbar,P.n))])
fn decompressc1
( reg mut ptr u16[Params::mbar*Params::n] C1
) -> reg ptr u16[Params::mbar*Params::n] /* C1 */
{
  reg u64 i;
  reg u16 x;
  if ( Params::logq1 != 12 ) {
    i = 0;
    while ( i < Params::mbar*Params::n ) {
      x = C1[i];
      x = decompress_q1(x, Params::logq1);
      C1[i] = x;
      i += 1;
    }
  }
  return C1;
}


inline fn compress_q2
( reg u16 x
, inline int logq2
) -> reg u16 /* x */
{
  reg u32 y, yrem;
  reg bool zf;

  y = (32u) x;
  y <<= logq2;
  y += 2048;
  y >>= 12;
  y &= ((1<<logq2)-1);
  yrem = y;
  yrem -= 1;
  if ( logq2 == 7 ) { // l==128 || l==256
    x &= 63;
    ?{ZF=zf}, x = #SUB_16(x,48);
    y = yrem if zf;
    y &= 0x7F;
  } else if ( logq2 == 10 ) { // l==192
    x &= 7;
    ?{ZF=zf}, x = #SUB_16(x,6);
    y = yrem if zf;
    y &= 0x3FF;
  } else {
    y = 0;
  }
  x = (16u) y;
  return x;
}

//      , funD('compressc2','j_compressc2', [argT.oarr(np.uint16,(P.mbar,P.nbar)),argT.iarr(np.uint16,(P.mbar,P.nbar))])
fn compressc2
( reg mut ptr u16[Params::mbar*Params::nbar] C2
) -> reg ptr u16[Params::mbar*Params::nbar] /* C2 */
{
  reg u64 i;
  reg u16 x;
  i = 0;
  while ( i < Params::mbar*Params::nbar ) {
    x = C2[i];
    x = compress_q2(x, Params::logq2);
    C2[i] = x;
    i += 1;
  }
  return C2;
}

inline fn decompress_q2
( reg u16 x
, inline int logq2
) -> reg u16 /* x */
{
  reg u32 y;
  y = (32u) x;
  y &= ((1<<logq2)-1);
  y <<= 12;
  y += (1 << (logq2-1));
  y >>= logq2;
  x = (16u) y;
  return x;
}

//      , funD('decompressc2','j_decompressc2', [argT.oarr(np.uint16,(P.mbar,P.nbar),argT.iarr(np.uint16,(P.mbar,P.nbar)))])
fn decompressc2
( reg mut ptr u16[Params::mbar*Params::nbar] C2
) -> reg ptr u16[Params::mbar*Params::nbar] /* C2 */
{
  reg u64 i;
  reg u16 x;
  i = 0;
  while ( i < Params::mbar*Params::nbar ) {
    x = C2[i];
    x = decompress_q2(x, Params::logq2);
    C2[i] = x;
    i += 1;
  }
  return C2;
}

//      , funD('packc1','j_packc1', [argT.oarr(np.uint8,(P.c1,)),argT.iarr(np.uint16,(P.mbar,P.n))])
fn packc1
( reg mut ptr u8[Params::c1] c1
, reg const ptr u16[Params::mbar*Params::n] C1
) -> reg ptr u8[Params::c1] /* c1 */
{
  reg u64 x, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( i < 2*Params::mbar*Params::n ) { // obs: 8 %| Params::mbar*Params::n
    if ( Params::logq1 == 9) { // Params::l == 128
      x = C1.[:u64 i];
      r = 0;
      r = pack4(x, r, 0, 9);
      c1.[:u8 j] = (8u) r;
      r >>= 8;
      x = C1.[:u64 i+8];
      r = pack4(x, r, 28, 9);
      c1.[:u64 j+1] = r;
      j += 9;
    } else if ( Params::logq1 == 12) { // Params::l == 192
      x = C1.[:u64 i];
      r = 0;
      r = pack4(x, r, 0, 12);
      c1.[:u32 j] = (32u) r;
      r >>= 32;
      x = C1.[:u64 i+8];
      r = pack4(x, r, 16, 12);
      c1.[:u64 j+4] = r;
      j += 12;
    } else if ( Params::logq1 == 10) { // Params::l == 256
      x = C1.[:u64 i];
      r = 0;
      r = pack4(x, r, 0, 10);
      c1.[:u16 j] = (16u) r;
      r >>= 16;
      x = C1.[:u64 i+8];
      r = pack4(x, r, 24, 10);
      c1.[:u64 j+2] = r;
      j += 10;
    }
    i += 16;
  }

  return c1;
}


//      , funD('unpackc1','j_unpackc1', [argT.oarr(np.uint16,(P.mbar,P.n)),argT.iarr(np.uint8,(P.c1,))])
fn unpackc1
( reg mut ptr u16[Params::mbar*Params::n] C1
, reg const ptr u8[Params::c1] c1
) -> reg ptr u16[Params::mbar*Params::n] /* C1 */
{
  reg u64 x, y, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( j < 2*Params::mbar*Params::n ) { // obs: 8 %| Params::mbar*Params::n
    if ( Params::logq1 == 9) { // Params::l == 128
      x = c1.[:u64 i];
      y = x;
      y >>= 4*Params::logq1;
      r = unpack4(x, Params::logq1);
      C1.[:u64 j] = r;
      x = (64u) c1.[:u8 i+8];
      x <<= (64-4*Params::logq1);
      x |= y;
      r = unpack4(x, Params::logq1);
      C1.[:u64 j+8] = r;
      i += Params::logq1;
    } else if ( Params::logq1 == 12) { // Params::l == 192
      x = c1.[:u64 i];
      y = x;
      y >>= 48;
      r = unpack4(x, 12);
      C1.[:u64 j] = r;
      x = (64u) c1.[:u32 i+8];
      x <<= 16;
      x |= y;
      r = unpack4(x, 12);
      C1.[:u64 j+8] = r;
      i += 12;
    } else if ( Params::logq1 == 10) { // Params::l == 256
      x = c1.[:u64 i];
      y = x;
      y >>= 40;
      r = unpack4(x, 10);
      C1.[:u64 j] = r;
      x = (64u) c1.[:u16 i+8];
      x <<= 24;
      x |= y;
      r = unpack4(x, 10);
      C1.[:u64 j+8] = r;
      i += 10;
    }
    j += 16;
  }

  return C1;
}


//      , funD('packc2','j_packc2', [argT.oarr(np.uint8,(P.c2,)),argT.iarr(np.uint16,(P.mbar,P.nbar))])
fn packc2
( reg mut ptr u8[Params::c2] c2
, reg const ptr u16[Params::mbar*Params::nbar] C2
) -> reg ptr u8[Params::c2] /* c2 */
{
  reg u64 x, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( i < 2*Params::mbar*Params::nbar-16 ) { // obs: 8 doesn't divide Params::mbar*Params::nbar for l==256
    if ( Params::logq2 == 7) { // Params::l==128 (u16[64]) || l==256 (u16[132])
      x = C2.[:u64 i];
      r = 0;
      r = pack4(x, r, 0, 7);
      c2.[:u32 j] = (32u) r;
      r >>= 24;
      x = C2.[:u64 i+8];
      r = pack4(x, r, 4, 7);
      c2.[:u32 j+3] = (32u) r;
      j += 7;
    } else if ( Params::logq2 == 10) { // Params::l == 192 (u16[64])
      x = C2.[:u64 i];
      r = 0;
      r = pack4(x, r, 0, 10);
      c2.[:u16 j] = (16u) r;
      r >>= 16;
      x = C2.[:u64 i+8];
      r = pack4(x, r, 24, 10);
      c2.[:u64 j+2] = r;
      j += 10;
    }
    i += 16;
  }
  if ( Params::l == 128) { // Params::logq2==7 (8 entries missing)
    x = C2.[:u64 i];
    r = 0;
    r = pack4(x, r, 0, 7);
    c2.[:u32 j] = (32u) r;
    r >>= 24;
    x = C2.[:u64 i+8];
    r = pack4(x, r, 4, 7);
    c2.[:u32 j+3] = (32u) r;
  } else if ( Params::l == 256) { // Params::logq2==7 (4 entries missing)
    x = C2.[:u64 i];
    r = 0;
    r = pack4(x, r, 0, 7);
    c2.[:u32 j] = (32u) r;
  } else if ( Params::logq2 == 10) { // Params::l == 192 (u16[64])
    x = C2.[:u64 i];
    r = 0;
    r = pack4(x, r, 0, 10);
    c2.[:u16 j] = (16u) r;
    r >>= 16;
    x = C2.[:u64 i+8];
    r = pack4(x, r, 24, 10);
    c2.[:u64 j+2] = r;
  }

  return c2;
}

//      , funD('unpackc2','j_unpackc2', [argT.oarr(np.uint16,(P.mbar,P.nbar)),argT.iarr(np.uint8,(P.c2,))])
fn unpackc2
( reg mut ptr u16[Params::mbar*Params::nbar] C2
, reg const ptr u8[Params::c2] c2
) -> reg ptr u16[Params::mbar*Params::nbar] /* C2 */
{
  reg u64 x, y, r;
  reg ui64 i, j;

  j = 0;
  i = 0;
  while ( j < 2*Params::mbar*Params::nbar-16 ) { // obs: 8 does not divide Params::mbar*Params::nbar for l==256 (4 entries missing)
    if ( Params::logq2 == 7) { // Params::l==128 (u16[64]) || l==256 (u16[132])
      x = (64u) c2.[:u32 i];
      r = unpack4(x, 7);
      C2.[:u64 j] = r;
      x = (64u) c2.[:u32 i+3];
      x >>= 4;
      r = unpack4(x, 7);
      C2.[:u64 j+8] = r;
      i += 7;
    } else if ( Params::logq2 == 10) { // Params::l == 192
      x = c2.[:u64 i];
      y = x;
      y >>= 40;
      r = unpack4(x, 10);
      C2.[:u64 j] = r;
      x = (64u) c2.[:u16 i+8];
      x <<= 24;
      x |= y;
      r = unpack4(x, 10);
      C2.[:u64 j+8] = r;
      i += 10;
    }
    j += 16;
  }
  if ( Params::logq2==7 && Params::l == 128) { // (8 entries missing)
    x = (64u) c2.[:u32 i];
    r = unpack4(x, 7);
    C2.[:u64 j] = r;
    x = (64u) c2.[:u32 i+3];
    x >>= 4;
    r = unpack4(x, 7);
    C2.[:u64 j+8] = r;
  } else if ( Params::logq2==7 && Params::l == 256) {// (8 entries missing)
    x = (64u) c2.[:u32 i];
    r = unpack4(x, 7);
    C2.[:u64 j] = r;
  } else if ( Params::logq2 == 10) { // Params::l == 192
    x = c2.[:u64 i];
    y = x;
    y >>= 40;
    r = unpack4(x, 10);
    C2.[:u64 j] = r;
    x = (64u) c2.[:u16 i+8];
    x <<= 24;
    x |= y;
    r = unpack4(x, 10);
    C2.[:u64 j+8] = r;
  }

 return C2;
}